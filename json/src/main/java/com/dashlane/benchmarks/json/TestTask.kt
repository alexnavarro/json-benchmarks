package com.dashlane.benchmarks.json

import android.os.AsyncTask
import java.io.File
import java.util.*
import kotlin.system.measureNanoTime

/**
 * Run a series of tests.
 *
 * @param dir
 *  The directory in which to write the files generated by the test.
 * @param repeat
 *  The number of times to repeat each test.
 */
class TestTask(
        private val dir: File,
        private val repeat: Int
): AsyncTask<JsonTest.Factory, Pair<Int, Int>, Unit>() {

    var onProgress: ((Pair<Int, Int>) -> Unit)? = null

    override fun doInBackground(vararg args: JsonTest.Factory) {
        if (dir.exists()) check(dir.delete()) { "Unable to delete $dir" }
        check(dir.mkdirs()) { "Unable to create $dir" }

        try {
            args.withIndex().forEach { (idx, test) -> repeatTest(idx, test) }
        } catch (t: Throwable) {
            Log.w("!!! Tests cancelled due to $t")
            t.printStackTrace()
        }
        Log.i("")
        Log.i("[TEST] Test run done!")
    }

    override fun onProgressUpdate(vararg values: Pair<Int, Int>) {
        values.forEach { onProgress?.invoke(it) }
    }

    private fun repeatTest(testIndex: Int, testFactory: JsonTest.Factory) {
        Log.i("")
        Log.i("[TEST] ${testFactory.testName}")
        val timeNanos = measureNanoTime {
            val testRun = List(repeat) { idx ->
                publishProgress(testIndex to idx)
                runTestInstance(testFactory)
            }

            val jsonSize = testRun.average(TestRun::jsonSize)
            val writeFileDurationNanos = testRun.average(TestRun::writeFileDurationNanos)
            val testResults = testRun.map(TestRun::result)
            val gsonNanoTime = testResults.map { number -> number[0] }.average().toLong()
            val immutableGsonNanoTime = testResults.map { number -> number[1] }.average().toLong()
            val jsonNanoTime = testResults.map { number -> number[2] }.average().toLong()
            val kotlinSerializeNanoTime = testResults.map { number -> number[3] }.average().toLong()
            val moshiTime = testResults.map { number -> number[4] }.average().toLong()
            Log.i("[TEST] Average JSON size: ${formatSize(jsonSize)}")
            Log.i("[TEST] Average time to write JSON to file: ${formatDuration(writeFileDurationNanos)}")
            Log.i("[TEST] Average Gson time: ${formatDuration(gsonNanoTime)}")
            Log.i("[TEST] Average Immutable Gson time: ${formatDuration(immutableGsonNanoTime)}")
            Log.i("[TEST] Average JSON time: ${formatDuration(jsonNanoTime)}")
            Log.i("[TEST] Average Kotlin Serialize time: ${formatDuration(kotlinSerializeNanoTime)}")
            Log.i("[TEST] Average Moshi time: ${formatDuration(moshiTime)}")
        }
        Log.i("[TEST] Total running time ${formatDuration(timeNanos)}")
    }

    private fun runTestInstance(testFactory: JsonTest.Factory): TestRun {
        check(!isCancelled) { "Task cancelled" }
        val test = testFactory.create()
        val jsonLength = test.json.toByteArray().size
        val file = File(dir, UUID.randomUUID().toString())
        val writeJsonTimeNanos = measureNanoTime { file.writeText(test.json) }
        val testResult = listOf(
                measureNanoTime { test.parseGson() }
                        .also { Log.d("[RunTest] Gson took $it nanoseconds") },
                measureNanoTime { test.parseImmutableGson() }
                        .also { Log.d("[RunTest] Immutable Gson took $it nanoseconds") },
                measureNanoTime { test.parseOrgJson() }
                        .also { Log.d("[RunTest] JSON took $it nanoseconds") },
            measureNanoTime { test.parseKotlinSerialization() }
                .also { Log.d("[RunTest] Kotlin Serialize took $it nanoseconds") },
            measureNanoTime { test.parseMoshi() }
                .also { Log.d("[RunTest] Moshi took $it nanoseconds") }
        )
        return TestRun(jsonLength, writeJsonTimeNanos, testResult)
    }

    private class TestRun(
            val jsonSize: Int,
            val writeFileDurationNanos: Long,
            val result: List<Long>
    )
}